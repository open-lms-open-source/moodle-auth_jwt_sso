<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Authentication Plugin: Shared URL JWT Authentication
 * Authenticates against using a shared secret generated by the website
 *
 * @package auth_jwt_sso
 * @author Lupiya Mujala <lupiya@ecreators.com.au>
 *
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->libdir . '/authlib.php');
require_once($CFG->libdir . '/moodlelib.php');
require_once($CFG->dirroot . '/auth/jwt_sso/lib/jwt/vendor/autoload.php');
require_once($CFG->dirroot . '/user/lib.php');

use Firebase\JWT\JWT;


/**
 * Shared Cookie authentication plugin.
 */

class auth_plugin_jwt_sso extends auth_plugin_base {

    /**
     * Constructor.
     */
    public function __construct() {
        $this->authtype = 'jwt_sso';
        $this->config = get_config('auth_jwt_sso');
    }

    /**
     * jwt_cookie uses loginpage_hook and pre_loginpage_hook to authenicate users.
     * This function is never called, see:
     * https://docs.moodle.org/dev/Authentication_plugins#Overview_of_Moodle_authentication_process
     *
     * @param string $username The username
     * @param string $password The password
     *
     * @return bool false always for this function as it's never called.
     */
    public function user_login($username, $password) {
        return false;
    }

    public function pre_loginpage_hook() {
        global $SESSION;

        $incoming_url = $SESSION->wantsurl;

        $valid_jwt = false;
        // Check for cookie.
        if($this->config->use_cookie || !isset($this->config->jwt_name)){
            $valid_jwt = $this->verify_cookie();
        }else if($this->config->jwt_name){
            $signed_jwt = optional_param($this->config->jwt_name, 0, PARAM_TEXT);
            // Let's verify the JWT.
            $valid_jwt = $this->verify_jwt($signed_jwt);
            if(!$valid_jwt){
                return;
            }
        }
        if($valid_jwt) {

            $user = $this->verify_user($valid_jwt);
            //Try to finish the user login.
            $this->finishUserLogin($user, $incoming_url);

        } else {
            $this->loginpage_hook();
        }
        $this->loginpage_hook();
    }


    /**
     * When the login page for moodle has been requested, run this function.
     * We attempt to auto log the user in, or redirect to the alternative login page.
     */
    public function loginpage_hook() {
        global $user;
        global $CFG, $SESSION;

        $redirect = optional_param('redirect', 1, PARAM_INT);
        $username = optional_param('username', '', PARAM_RAW);


        if ($redirect == 1){
            $SESSION->nologinredirect = null;
        }

        if ($redirect == 0 || (isset($SESSION->nologinredirect) && !$SESSION->nologinredirect)) {
            // Login page can redirect back to itself without parameters when there is an error message, e.g. session timeout.
            // Remember the redirect = 0 paramater accross this redirect using this custom session var.
            $SESSION->nologinredirect = true;
            return;
        }

        // If the username is set for the form, we will not validate or redirect.
        if (!empty($username) || isloggedin()) {
            return;
        }

        if($this->config->use_cookie || !isset($this->config->jwt_name)){
            $valid_jwt = $this->verify_cookie();
        }else if($this->config->jwt_name){
            $signed_jwt = optional_param($this->config->jwt_name, 0, PARAM_TEXT);
            // Let's verify the JWT.
            $valid_jwt = $this->verify_jwt($signed_jwt);
            if(!$valid_jwt){
                return;
            }
        }

        $user = $this->verify_user($valid_jwt);
        // Let's try to finish the login process.
        if($user){
            $this->finishUserLogin($user);
        }
    }

    protected function finishUserLogin($user, $incoming_url = ""){
        global $CFG;
        // JWT was not verified.
        if (($user) === false || $user ==null) {

            // Set the alternative login url to ours if it's not already set by a higher.
            // priority plugin.
            if (!empty($this->config->shared_login_url) && empty($CFG->alternateloginurl)) {
                $CFG->alternateloginurl = $this->config->shared_login_url;
                redirect($this->config->shared_login_url);
            }
            return;
        }

        // A valid jwt was found, but not a valid user.  Assume a login without an account.
        if ($user !== false && $user === null) {
            if (!empty($this->config->no_account_url) && empty($CFG->alternateloginurl)) {
                // Defined no user URL, send the person there via redirect.
                $CFG->alternateloginurl = $this->config->no_account_url;
                redirect($this->config->shared_login_url);
            }
            return;
        }

        //Complete the login here.
        if ($user !== false && $user != null) {
            if(!empty($incoming_url)){
                try {
                    complete_user_login($user);
                    redirect($incoming_url);
                } catch (Exception $e) {
                    //do nothing
                }
            }else{
                try {
                    complete_user_login($user);
                    $urltogo = core_login_get_return_url();
                    if($urltogo){
                        redirect($urltogo);
                    }else{
                        redirect($CFG->wwwroot .'/my');
                    }
                } catch (Exception $e) {
                    //do nothing
                }
            }
        }
    }

    /**
     * This attempts to parse the JWT from the URL
     */
    protected function verify_jwt($signed_jwt){
        global $CFG;

        $valid = false;

        // Check if the site actually has the secret set.
        if(!$this->config->secret){
            return $valid;
        }

        // Check if the signed JWT exists.
        if(empty($signed_jwt)){
            return $valid;
        }else{
            $valid = $this->decrypt_jwt($signed_jwt);
            return $valid;
        }
    }

    /**
     * This function will decrypt the JWT
     */
    protected function decrypt_jwt($signed_jwt){

        $secretKey = ($this->config->secret);
        if($this->config->secret_encoded){
            $secretKey = base64_decode($secretKey);
        }

        try{
            $claims = JWT::decode($signed_jwt, $secretKey, array('HS256'));
            $claims = (array) $claims;
        }catch(Exception $e){
            return false;
        }

        return $claims;
    }

    /**
     * This function will verify if the user account exists and complete the login.
     */
    protected function verify_user($userdata)
    {
        global $DB;

        if($userdata && isset($userdata['username'])){
            $user = $DB->get_record('user', array('username' => $userdata['username']));

            $newuser = false;
            if(!$user){
                $user = create_user_record($userdata['username'], '', $this->authtype);
                $newuser = true;
            }

            $this->update_user_profile_fields($user, $userdata, $newuser);

            try {
                $user = get_complete_user_data('id', $user->id);
            } catch (dml_multiple_records_exception $e) {
                // Multiple users are configured with this id.
                debugging('Multiple users have the same idnumber configured for this authtype. idnumber: '.$user->id, DEBUG_ALL);
                return false;
            } catch (dml_missing_record_exception $e) {
                // No users are configured with this id.
                debugging('No users configured with idnumber for this authtype. idnumber: ' . $user->id, DEBUG_ALL);
                return false;
            }

            return $user;
        }else{
            return false;
        }
    }

    public function update_user_profile_fields(&$user, $userdata, $newuser = false) {
        global $CFG;

        $update = false;
        // Update the user fields.
        $allowed_fields = array('firstname', 'lastname', 'description', 'email', 'username');
        foreach ($allowed_fields as $field){
            if(isset($userdata[$field])) {
                $user->{$field} = $userdata[$field];
                $update = true;
            }
        }

        // Update the profile.
        if($update){
            require_once($CFG->dirroot . '/user/lib.php');
            require_once($CFG->dirroot . '/user/profile/lib.php');
            user_update_user($user, false, false);
            // Save custom profile fields.
            profile_save_data($user);
        }
    }

    /**
     * Verify a cookie we have recieved and determine the user it belongs to.
     *
     * @return integer|bool If the cookie was valid return the id, false otherwise.
     */
    protected function verify_cookie() {

        if (!isset($_COOKIE[$this->config->cookie_name])) {
            return false;
        }

        // The cookie can be encoded incorrectly with spaces instead of +'s in URL enoding.
        $string = $_COOKIE[$this->config->cookie_name];
        $userdata = $this->decrypt_jwt($string);

        return $userdata;

    }

    /**
     * Upon logout remove the cookie to ensure we won't automatically log back in.
     */
    function logoutpage_hook() {
        global $USER;

        if ($USER->auth === $this->authtype){
            setcookie($this->config->cookie_name, null, time() - (86400 * 30), '/', $this->config->shared_cookie_domain);
            unset($_COOKIE[$this->config->cookie_name]);
        }
    }

    /**
     * Determine the url (if any) to send the user to after logout.
     *
     * @param stdClass $user The user record just prior to logout.
     */
    public function postlogout_hook($user) {
        global $redirect;  // This is used to completed a redirect after a user has logged out.

        // Only do this if the user is actually logged in via jwt_cookie.
        if ($user->auth === $this->authtype) {
            // Check if there is an alternative logout url defined
            if (isset($this->config->logout_url) && !empty($this->config->logout_url)) {
                $redirect = $this->config->logout_url;
            }
        }
    }
}
